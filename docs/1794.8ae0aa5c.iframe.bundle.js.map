{"version":3,"file":"1794.8ae0aa5c.iframe.bundle.js","mappings":"AAAA","sources":["webpack://ledfx/./src/components/PixelGraph/pixelGraphWorkerWebGL.js"],"sourcesContent":["/* eslint-disable no-restricted-globals */\nself.onmessage = (event) => {\n  if (event.data.canvas) {\n    self.canvas = event.data.canvas\n    self.gl = self.canvas.getContext('webgl') || self.canvas.getContext('experimental-webgl')\n    if (!self.gl) {\n      console.error('WebGL not supported')\n      return\n    }\n\n    // Initialize WebGL\n    self.initWebGL()\n  } else if (event.data.pixels) {\n    const { pixels, rows, cols } = event.data\n    self.canvas.width = cols\n    self.canvas.height = rows\n    self.gl.viewport(0, 0, cols, rows)\n\n    // Update texture with new pixel data\n    self.updateTexture(pixels, rows, cols)\n  }\n}\n\nself.initWebGL = () => {\n  const vertexShaderSource = `\n    attribute vec2 a_position;\n    attribute vec2 a_texCoord;\n    varying vec2 v_texCoord;\n    void main() {\n      gl_Position = vec4(a_position, 0.0, 1.0);\n      v_texCoord = a_texCoord;\n    }\n  `\n\n  const fragmentShaderSource = `\n    precision mediump float;\n    varying vec2 v_texCoord;\n    uniform sampler2D u_texture;\n    void main() {\n      gl_FragColor = texture2D(u_texture, v_texCoord);\n    }\n  `\n\n  const vertexShader = self.createShader(self.gl.VERTEX_SHADER, vertexShaderSource)\n  const fragmentShader = self.createShader(self.gl.FRAGMENT_SHADER, fragmentShaderSource)\n  const program = self.createProgram(vertexShader, fragmentShader)\n\n  self.gl.useProgram(program)\n\n  // Look up where the vertex data needs to go.\n  const positionLocation = self.gl.getAttribLocation(program, 'a_position')\n  const texCoordLocation = self.gl.getAttribLocation(program, 'a_texCoord')\n\n  // Create a buffer and put a single clipspace rectangle in it (2 triangles)\n  const positionBuffer = self.gl.createBuffer()\n  self.gl.bindBuffer(self.gl.ARRAY_BUFFER, positionBuffer)\n  self.gl.bufferData(self.gl.ARRAY_BUFFER, new Float32Array([\n    -1.0, -1.0,\n     1.0, -1.0,\n    -1.0,  1.0,\n    -1.0,  1.0,\n     1.0, -1.0,\n     1.0,  1.0,\n  ]), self.gl.STATIC_DRAW)\n\n  // Create a buffer for texture coordinates\n  const texCoordBuffer = self.gl.createBuffer()\n  self.gl.bindBuffer(self.gl.ARRAY_BUFFER, texCoordBuffer)\n  self.gl.bufferData(self.gl.ARRAY_BUFFER, new Float32Array([\n    0.0, 1.0,\n    1.0, 1.0,\n    0.0, 0.0,\n    0.0, 0.0,\n    1.0, 1.0,\n    1.0, 0.0,\n  ]), self.gl.STATIC_DRAW)\n\n  // Create a texture\n  self.texture = self.gl.createTexture()\n  self.gl.bindTexture(self.gl.TEXTURE_2D, self.texture)\n  self.gl.texParameteri(self.gl.TEXTURE_2D, self.gl.TEXTURE_WRAP_S, self.gl.CLAMP_TO_EDGE)\n  self.gl.texParameteri(self.gl.TEXTURE_2D, self.gl.TEXTURE_WRAP_T, self.gl.CLAMP_TO_EDGE)\n  self.gl.texParameteri(self.gl.TEXTURE_2D, self.gl.TEXTURE_MIN_FILTER, self.gl.NEAREST)\n  self.gl.texParameteri(self.gl.TEXTURE_2D, self.gl.TEXTURE_MAG_FILTER, self.gl.NEAREST)\n\n  // Tell WebGL how to pull out the positions from the position buffer\n  self.gl.bindBuffer(self.gl.ARRAY_BUFFER, positionBuffer)\n  self.gl.enableVertexAttribArray(positionLocation)\n  self.gl.vertexAttribPointer(positionLocation, 2, self.gl.FLOAT, false, 0, 0)\n\n  // Tell WebGL how to pull out the texture coordinates from the texCoord buffer\n  self.gl.bindBuffer(self.gl.ARRAY_BUFFER, texCoordBuffer)\n  self.gl.enableVertexAttribArray(texCoordLocation)\n  self.gl.vertexAttribPointer(texCoordLocation, 2, self.gl.FLOAT, false, 0, 0)\n}\n\nself.createShader = (type, source) => {\n  const shader = self.gl.createShader(type)\n  self.gl.shaderSource(shader, source)\n  self.gl.compileShader(shader)\n  if (!self.gl.getShaderParameter(shader, self.gl.COMPILE_STATUS)) {\n    console.error('Error compiling shader:', self.gl.getShaderInfoLog(shader))\n    self.gl.deleteShader(shader)\n    return null\n  }\n  return shader\n}\n\nself.createProgram = (vertexShader, fragmentShader) => {\n  const program = self.gl.createProgram()\n  self.gl.attachShader(program, vertexShader)\n  self.gl.attachShader(program, fragmentShader)\n  self.gl.linkProgram(program)\n  if (!self.gl.getProgramParameter(program, self.gl.LINK_STATUS)) {\n    console.error('Error linking program:', self.gl.getProgramInfoLog(program))\n    self.gl.deleteProgram(program)\n    return null\n  }\n  return program\n}\n\nself.updateTexture = (pixels, rows, cols) => {\n  self.gl.bindTexture(self.gl.TEXTURE_2D, self.texture)\n  self.gl.texImage2D(\n    self.gl.TEXTURE_2D,\n    0,\n    self.gl.RGBA,\n    cols,\n    rows,\n    0,\n    self.gl.RGBA,\n    self.gl.UNSIGNED_BYTE,\n    new Uint8Array(pixels.flatMap(p => [p.r, p.g, p.b, 255]))\n  )\n\n  // Draw the rectangle\n  self.gl.clear(self.gl.COLOR_BUFFER_BIT)\n  self.gl.drawArrays(self.gl.TRIANGLES, 0, 6)\n}"],"names":[],"sourceRoot":""}