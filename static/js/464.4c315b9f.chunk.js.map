{"version":3,"file":"static/js/464.4c315b9f.chunk.js","mappings":"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","sources":["workers/pixelGraphWorkerWebGL.ts"],"sourcesContent":["/* eslint-disable no-restricted-globals */\ninterface Pixel {\n  r: number\n  g: number\n  b: number\n}\n\ninterface InitWebGLMessage {\n  canvas: OffscreenCanvas\n}\n\ninterface UpdateTextureMessage {\n  pixels: Pixel[]\n  rows: number\n  cols: number\n}\n\ntype WorkerMessageGL = InitWebGLMessage | UpdateTextureMessage\n\nlet canvasGL: OffscreenCanvas\nlet gl: WebGLRenderingContext | null\nlet texture: WebGLTexture | null\n\nself.onmessage = (event: MessageEvent<WorkerMessageGL>) => {\n  self.postMessage('worker-ready')\n  if ('canvas' in event.data) {\n    canvasGL = event.data.canvas\n    /* expect ts(2769) error */\n    gl =\n      (canvasGL.getContext('webgl' as OffscreenRenderingContextId) as WebGLRenderingContext) ||\n      (canvasGL.getContext(\n        'experimental-webgl' as OffscreenRenderingContextId\n      ) as WebGLRenderingContext)\n    if (!gl) {\n      console.error('WebGL not supported')\n      return\n    }\n\n    // Initialize WebGL\n    initWebGL()\n  } else if ('pixels' in event.data) {\n    const { pixels, rows, cols } = event.data\n    canvasGL.width = cols\n    canvasGL.height = rows\n    gl?.viewport(0, 0, cols, rows)\n\n    // Update texture with new pixel data\n    updateTexture(pixels, rows, cols)\n  }\n}\n\nconst initWebGL = () => {\n  const vertexShaderSource = `\n    attribute vec2 a_position;\n    attribute vec2 a_texCoord;\n    varying vec2 v_texCoord;\n    void main() {\n      gl_Position = vec4(a_position, 0.0, 1.0);\n      v_texCoord = a_texCoord;\n    }\n  `\n\n  const fragmentShaderSource = `\n    precision mediump float;\n    varying vec2 v_texCoord;\n    uniform sampler2D u_texture;\n    void main() {\n      gl_FragColor = texture2D(u_texture, v_texCoord);\n    }\n  `\n\n  const vertexShader = createShader(gl!.VERTEX_SHADER, vertexShaderSource)\n  const fragmentShader = createShader(gl!.FRAGMENT_SHADER, fragmentShaderSource)\n  const program = createProgram(vertexShader, fragmentShader)\n\n  gl!.useProgram(program)\n\n  // Look up where the vertex data needs to go.\n  if (!program) {\n    console.error('Failed to create WebGL program')\n    return\n  }\n  const positionLocation = gl!.getAttribLocation(program, 'a_position')\n  const texCoordLocation = gl!.getAttribLocation(program, 'a_texCoord')\n\n  // Create a buffer and put a single clipspace rectangle in it (2 triangles)\n  const positionBuffer = gl!.createBuffer()\n  gl!.bindBuffer(gl!.ARRAY_BUFFER, positionBuffer)\n  gl!.bufferData(\n    gl!.ARRAY_BUFFER,\n    new Float32Array([-1.0, -1.0, 1.0, -1.0, -1.0, 1.0, -1.0, 1.0, 1.0, -1.0, 1.0, 1.0]),\n    gl!.STATIC_DRAW\n  )\n\n  // Create a buffer for texture coordinates\n  const texCoordBuffer = gl!.createBuffer()\n  gl!.bindBuffer(gl!.ARRAY_BUFFER, texCoordBuffer)\n  gl!.bufferData(\n    gl!.ARRAY_BUFFER,\n    new Float32Array([0.0, 1.0, 1.0, 1.0, 0.0, 0.0, 0.0, 0.0, 1.0, 1.0, 1.0, 0.0]),\n    gl!.STATIC_DRAW\n  )\n\n  // Create a texture\n  texture = gl!.createTexture()\n  gl!.bindTexture(gl!.TEXTURE_2D, texture)\n  gl!.texParameteri(gl!.TEXTURE_2D, gl!.TEXTURE_WRAP_S, gl!.CLAMP_TO_EDGE)\n  gl!.texParameteri(gl!.TEXTURE_2D, gl!.TEXTURE_WRAP_T, gl!.CLAMP_TO_EDGE)\n  gl!.texParameteri(gl!.TEXTURE_2D, gl!.TEXTURE_MIN_FILTER, gl!.NEAREST)\n  gl!.texParameteri(gl!.TEXTURE_2D, gl!.TEXTURE_MAG_FILTER, gl!.NEAREST)\n\n  // Tell WebGL how to pull out the positions from the position buffer\n  gl!.bindBuffer(gl!.ARRAY_BUFFER, positionBuffer)\n  gl!.enableVertexAttribArray(positionLocation)\n  gl!.vertexAttribPointer(positionLocation, 2, gl!.FLOAT, false, 0, 0)\n\n  // Tell WebGL how to pull out the texture coordinates from the texCoord buffer\n  gl!.bindBuffer(gl!.ARRAY_BUFFER, texCoordBuffer)\n  gl!.enableVertexAttribArray(texCoordLocation)\n  gl!.vertexAttribPointer(texCoordLocation, 2, gl!.FLOAT, false, 0, 0)\n}\n\nconst createShader = (type: number, source: string): WebGLShader | null => {\n  const shader = gl!.createShader(type)\n  if (!shader) {\n    console.error('Error creating shader')\n    return null\n  }\n  gl!.shaderSource(shader, source)\n  gl!.compileShader(shader)\n  if (!gl!.getShaderParameter(shader, gl!.COMPILE_STATUS)) {\n    console.error('Error compiling shader:', gl!.getShaderInfoLog(shader))\n    gl!.deleteShader(shader)\n    return null\n  }\n  return shader\n}\n\nconst createProgram = (\n  vertexShader: WebGLShader | null,\n  fragmentShader: WebGLShader | null\n): WebGLProgram | null => {\n  const program = gl!.createProgram()\n  gl!.attachShader(program, vertexShader!)\n  gl!.attachShader(program, fragmentShader!)\n  gl!.linkProgram(program)\n  if (!gl!.getProgramParameter(program, gl!.LINK_STATUS)) {\n    console.error('Error linking program:', gl!.getProgramInfoLog(program))\n    gl!.deleteProgram(program)\n    return null\n  }\n  return program\n}\n\nconst updateTexture = (pixels: Pixel[], rows: number, cols: number) => {\n  gl!.bindTexture(gl!.TEXTURE_2D, texture)\n  gl!.texImage2D(\n    gl!.TEXTURE_2D,\n    0,\n    gl!.RGBA,\n    cols,\n    rows,\n    0,\n    gl!.RGBA,\n    gl!.UNSIGNED_BYTE,\n    new Uint8Array(pixels.flatMap((p) => [p.r, p.g, p.b, 255]))\n  )\n\n  // Draw the rectangle\n  gl!.clear(gl!.COLOR_BUFFER_BIT)\n  gl!.drawArrays(gl!.TRIANGLES, 0, 6)\n}\n"],"names":["canvasGL","gl","texture","self","onmessage","event","postMessage","data","canvas","getContext","console","error","initWebGL","_gl","pixels","rows","cols","width","height","viewport","updateTexture","vertexShader","createShader","VERTEX_SHADER","fragmentShader","FRAGMENT_SHADER","program","createProgram","useProgram","positionLocation","getAttribLocation","texCoordLocation","positionBuffer","createBuffer","bindBuffer","ARRAY_BUFFER","bufferData","Float32Array","STATIC_DRAW","texCoordBuffer","createTexture","bindTexture","TEXTURE_2D","texParameteri","TEXTURE_WRAP_S","CLAMP_TO_EDGE","TEXTURE_WRAP_T","TEXTURE_MIN_FILTER","NEAREST","TEXTURE_MAG_FILTER","enableVertexAttribArray","vertexAttribPointer","FLOAT","type","source","shader","shaderSource","compileShader","getShaderParameter","COMPILE_STATUS","getShaderInfoLog","deleteShader","attachShader","linkProgram","getProgramParameter","LINK_STATUS","getProgramInfoLog","deleteProgram","texImage2D","RGBA","UNSIGNED_BYTE","Uint8Array","flatMap","p","r","g","b","clear","COLOR_BUFFER_BIT","drawArrays","TRIANGLES"],"sourceRoot":""}